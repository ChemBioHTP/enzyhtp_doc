==============================================
Mutate protein with EnzyHTP mutation module 
==============================================

The target for this tutorial to mutate the target protein at defined residue(s). The main function provided are ``assign_mutant()`` and ``mutate_stru()``, which transfer mutation sites into a specific format and alter the original protein structure accordingly.

1. Assign the mutation sites.
==============================================

.. panels::

    :column: col-lg-12 col-md-12 col-sm-12 col-xs-12 p-2 text-left

    ``def assign_mutant``

    - ``Briefs``
        This science API assigns mutants targeted in the study. Decode the user assigned ``{pattern}`` based on the ``{stru}`` and get a list of mutants defined by a list of mutation objects each.

    - ``Input/Output``
        ``Input``:
            | ``stru``: The structure you need to mutant, generated by ``PDBParser``.
            | ``pattern``: What residue(s) you need to mutant.
            | ``chain_sync_list``: A clarified list indicating homo-chains in enzyme ploymer.
            | ``chain_index_mapper``: A clarified dictionary that indicates residue index in each chain.
            
        ``Output``:
            | A list of mutants defined each by a list of mutation objects.
            | *NOTE*: this function generates WT as ``[]`` or ``[Mutation(None, "WT", None, None)]`` unless directly indication. Act accordingly.

    - ``Arguments``
        ``stru``: 
            The target 'WT' structure.
        ``pattern``: 
            The pattern that defines the mutation (see syntax below)
        ``chain_sync_list``: 
            A list like [(A,C),(B,D)] to indicate homo-chains in enzyme ploymer (like dimer). Mutations will be **copied** to the correponding homo-chains as it is maybe  experimentally impossible to only do mutations on one chain of a homo-dimer enzyme.
        ``random_state``: 
            The int() seed for the random number generator. Default value is 100.
        ``chain_index_mapper``: 
            Add biopython pairwise2.align.globalxx


    - ``Example``
        .. code-block:: python

            from enzy_htp.structure import PDBParser
            import enzy_htp.mutation.api as mapi
            
            test_pdb = "./test.pdb"
            test_mutation_pattern = (
                    "GA11A, {NA176W, PA51A},"
                    " {L56A, r:2[resi 254 around 3:all not self]*5}"
                    )    
            test_stru = PDBParser.get_structure(test_pdb)
            mutants = mapi.assign_mutant(test_stru, test_mutation_pattern, chain_sync_list=[("A", "B")], chain_index_mapper={"A": 0, "B": 0})
            print(mutants)

    - *Pattern Syntax:*
        | "mutant_1,mutant_2,mutant_3,..."
        | The top layer of the mutation_pattern specify mutants with comma seperated pattern.
        | In the pattern of each mutant, there could be more than one sections, but if multiple sections are used, {} is needed to group those sections. "{section_a1,section_a2,section_a3},{section_b1,section_b2, section_b3},..."
        | Each section can be one of the format below:

        1. direct indication: 
            ``XA###Y`` ('WT' for just wild type)
        2. random M, N-point mutation in a set: 
            | ``r:N[mutation_esm_patterns]*M`` or ``r:NR[mutation_esm_patterns]*MR``
            | (N and M are int, R stands for allowing repeating| mutations in randomization)
        3. all mutations in a set:             
            | ``a:[mutation_esm_patterns]`` or ``a:M[mutation_esm_patterns]`` 
            | (M stands for force mutate each position so that no mutation on any position is not allowed)

        The mutation_esm_patterns is seperated by comma and each describes 2 things:

        1. position_pattern:
            | a set of positions (check selection syntax in .mutation_pattern.position_pattern) 
            | NOTE: all non polypeptide part are filtered out.
        2. target_aa_pattern:
            | a set of target mutations apply to all positions in the current set (check syntax in .mutation_pattern.target_aa_pattern)

        The two pattern are seperated by ":" and a mutation_esm_patterns looks like: "position_pattern_0:target_aa_pattern_0, ..."

        * In 2&3 the pattern may indicate a mutant collection, if more than one mutant collection are indicated in the same {}, all combination of them is considered.

        Overall an example of pattern will be: ``"{RA154W, DA11G}, r:2[resi 289 around 4 and not resi 36:larger, proj(id 1000, id 2023, positive, 10) :more_negative_charge]*100"``

        * Here ``proj()`` is a hypothetical selection function

    - *Details:*

        | Which mutations should we study is a non-trivial question. Mutations could be assigned from a database or a site-saturation requirement. It reflexs the scientific question defined Assigning the mutation requires converting chemical/structural language to strict mutation definitions. Some fast calculations can also be done during the selection of mutations. (e.g.: calculating residues aligned with the projection line of the reacting bond [ref]) 
        | There are no existing software besides EnzyHTP addressing this challenge. 
        | A language that helps user to assign mutations is defined above.




2. Alter the original protein structure according to assigned mutant sites.
===========================================================================

.. panels::

    :column: col-lg-12 col-md-12 col-sm-12 col-xs-12 p-2 text-left

    ``def mutate_stru``

    - ``Briefs``
        This science API solves the problem of protein structural prediction upon mutation. It means to determine which mutation to address and determine the structure of the mutant of the source protein caused by residue substitution, deletion, and insertion. (see also: structure_prediction module for an alternative solution)
    
    - ``Input/Output``
        ``Input``:
            | ``stru``: The structure you need to mutant, generated by ``PDBParser``.
            | ``mutation_list``: A target list of mutation objects, generated by the ``assign_mutant`` function.
            | ``engine``: The method(tleap_min/pymol/rosetta et al.) used for determine the mutated structure.
        ``Output``: 
            The reference/copy of the changed structure (depends on the in_place value)

    - ``Arguments``
        ``stru``: 
            The target 'WT' structure.
        ``mutation_list``: 
            A target list of mutation objects. (normally generated by the `assign_mutant`` function. Generally dont recommand generating them manually).
        
        ``engine``: 
            The engine (method) used for determine the mutated structure

            | (current available keywords):
            | tleap_min
            | pymol
            | rosetta

        ``in_place``:   
            If change the structure in-place and return the reference. False means return a changed structure_obj and keep the original object intact (default is False since wild-type structure is expected to also available in many applications).

        ``if_check_mutant_stru``: 
            Support turning the mutant structure check off. (on by default)
        
        ``checker_config``: 
            | Config which checkers to use and their corresponding kwargs.
            | {'checker_name':{'keyword':value, ...}, ...}
            | (by default apply all checker)

    - ``Example``
        .. code-block:: python

            from enzy_htp.structure import PDBParser
            import enzy_htp.mutation.api as mapi
            
            test_pdb = "./test.pdb"
            test_stru = PDBParser.get_structure(test_pdb)
            test_mutant = mapi.assign_mutant(test_stru, "GA11A")
            mutant_stru = mapi.mutate_stru(test_stru, test_mutant[0], "pymol")
            print(mutant_stru)

    - *Details:*
        | Unlike predicting the whole protein structure from sequence and smiles, mutating a structure from a reference structure involves only changes on a limit number of residues and perturbation of the rest of the structure (especially ligand binding, protonation state etc.) As a result, it can be solved using more efficient methods and predicting the whole structure from sketch. Note that the accuracy of the resulting structure varies base on the need. If followed by MD, the structure only needs to be good starting point of MD.
        | There are 3 types of mutations in protein sequence: substitution, deletion, and insertion.
        | Substitution is the most common type of the mutation. In this case, only the side-chain is replaced by another type of the side-chain. And determining the conformation of the new side-chain is the main challenge. It also relates to side-chain conformation prediction in the field of structural prediction.
        | Deletion and insertion involve backbone changes.

    - *Avaible strageties:*
        Substitution:

        Direct replacement of the side-chain:

        - tleap_min (https://pubs.acs.org/doi/full/10.1021/acs.jcim.1c01424)
            The most simple way to get a mutant structure. It 1. place the new side-chain using a constant conformation (relative to backbone) and 2. relax the crude mutant structure using MM minimization.

            Consider limited change of other side chains in MM minimization
            Not consider backbone change

            * This method particularly has problem when mutating a small residue to a larger one. In this case, collision may appears in the mutated structure and the MM minimization is responsible for resolving it. But in extreme cases, there are unresolvable collision such as the carbon chain is trapped in a phenyl ring. And currently we don't have a method to detect such trapping. The method is only used as a place holder for 1st version EnzyHTP. We have encounter any problem brought by the accuracy of the mutation when using this method in workflows but users should be cautious with it and consider it a potential source of absured results.
        
        Side-chain rotamer library:
        (most used in the field)
        
        - SCWRL4 (http://dunbrack.fccc.edu/lab/scwrl)
            | Not consider other side-chain change
            | Not consider backbone change
        - PyMol (https://github.com/schrodinger/pymol-open-source)
            | Not consider other side-chain change
            | Not consider backbone change
        - Phyre2
            | Consider other side-chain change
            | Not consider backbone change

            * seems having a derived pipeline Missense3D addressing the challenge (https://www.sciencedirect.com/science/article/pii/S0022283619302037?via%3Dihub#s0050)

            * related discussion in its website (http://www.sbg.bio.ic.ac.uk/phyre2/html/help.cgi?id=help/faq)

        Machine learning methods:

        - Packpred (http://cospi.iiserpune.ac.in/packpred/, https://www.frontiersin.org/articles/10.3389/fmolb.2021.646288/full, https://github.com/kuanpern/PackPred)

          * find a summary of the missence mutation in the intro of the paper
            Unknown

        MCMC search globally in side-chains:

        - Modeller

            | Fully consider other side-chain change
            | Not consider backbone change
        - SWISSMODEL
            | Fully consider other side-chain change
            | Not consider backbone change


    - *Insertion/Deletion:*

        - Phyre4
            see http://www.sbg.bio.ic.ac.uk/phyre2/html/help.cgi?id=help/faq
            works mainly <5 AA change


3. Additional mutation APIs.
===========================================================================

.. panels::

    :column: col-lg-12 col-md-12 col-sm-12 col-xs-12 p-2 text-left

    ``def sync_mutation_over_chains``

    - ``Briefs``
        This science API synchronize mutations of each mutant in {mutants} to correponding chains. Return a copy of mutants with addition mutations in each mutant.

    - ``Input/Output``
        ``Input``:
            | ``mutants``: A list of target mutant, from clarification.
            | ``chain_sync_list``: A list indicating homo-chains in enzyme ploymer, from clarification.
            | ``chain_index_mapper``: A dictionary that indicates residue index in each chain, from clarification.

        ``Output``:
            A copy of mutants with addition mutations in each mutant

    - ``Arguments``
        ``mutants``: 
            A list of target mutant.
        ``chain_sync_list``: 
            A list like [(A,C),(B,D)] to indicate homo-chains in enzyme ploymer (like dimer). Mutations will be **copied** to the correponding homo-chains as it is maybe experimentally impossible to only do mutations on one chain of a homo-dimer enzyme.
        ``chain_index_mapper``: 
            Add biopython pairwise2.align.globalxx A temp solution for cases that residue index in each chain is not aligned. (e.g.: for a pair of homo-dimer below:
            
            "A": ABCDEFG (start from 7) 
            | "B": BCDEFGH (start from 14)
            | The chain_sync_mapper should be ``{"A":0, "B":6}`` and index conversion is done by A_res_idx - 0 + 6 = B_res_idx)

    - ``Example``
        .. code-block:: python

            import enzy_htp.mutation.api as mapi
            from enzy_htp.mutation.mutation import Mutation

            test_mutants = [[
                Mutation(orig='ARG', target='ALA', chain_id='A', res_idx=3),
                Mutation(orig='ARG', target='TRP', chain_id='A', res_idx=4)],
                [Mutation(orig='TRP', target='GLY', chain_id='C', res_idx=1),
                Mutation(orig='TRP', target='HIS', chain_id='C', res_idx=2)]]
            test_chain_sync_list = [("A", "B"), ("C", "D")]
            test_chain_index_mapper = {"A": 0, "B": 10, "C": 20, "D": 100}
            result = mapi.sync_mutation_over_chains(test_mutants, test_chain_sync_list, test_chain_index_mapper)
            print(result)


    ``def mutate_stru_with_tleap``

    - ``Briefs``
        Mutate the {stru} to its {mutant} structure using tleap from AmberMD package.

    - ``Input/Output``
        ``Input``:
            | ``stru``: The structure you need to mutant, generated by ``PDBParser``.
            | ``mutant``: A target list of mutation objects, generated by the ``assign_mutant`` function.

        ``Output``: 
            The reference/copy of the changed structure using tleap.
            
    - ``Arguments``
        ``stru``: 
            The target 'WT' structure.

        ``mutant``: 
            A list of Mutation() which describes a mutant to the 'WT'

        ``in_place``:   
            If change the structure in-place and return the reference. False means return a changed structure_obj and keep the original object intact (default is False since wild-type structure is expected to also available in many applications).

        ``int_pdb_path``: 
            Temp file path for PDB of {stru}, which original side chain atoms are deleted and original residue name changed.

        ``int_leap_pdb_path``: 
            Temp file path for tleap generated mutant PDB

    - ``Example``
        .. code-block:: python
            
            from enzy_htp.structure import PDBParser
            import enzy_htp.mutation.api as mapi
            
            test_pdb = "./test_A.pdb"
            test_stru = PDBParser.get_structure(test_pdb)
            test_mutant = mapi.assign_mutant(test_stru, "GA11A")
            mutant_stru = mapi.mutate_stru_with_tleap(test_stru, test_mutant[0])
            print(mutant_stru)


    ``def mutate_stru_with_pymol``

    - ``Briefs``
        Mutate the {stru} to its {mutant} structure using PyMOL.

    - ``Input/Output``
        ``Input``:
            | ``stru``: The structure you need to mutant, generated by ``PDBParser``.
            | ``mutant``: A target list of mutation objects, generated by the ``assign_mutant`` function.

        ``Output``: 
            The reference/copy of the changed structure using PyMOL.
    
    - ``Arguments``
        ``stru``: 
            The target 'WT' structure.

        ``mutant``: 
            a list of Mutation() which describes a mutant to the 'WT'

        ``in_place``: 
            if make the changes to the structure in-place 

    - ``Example``
        .. code-block:: python
            
            from enzy_htp.structure import PDBParser
            import enzy_htp.mutation.api as mapi
            
            test_pdb = "./test_A.pdb"
            test_stru = PDBParser.get_structure(test_pdb)
            test_mutant = mapi.assign_mutant(test_stru, "GA11A")
            mutant_stru = mapi.mutate_stru_with_pymol(test_stru, test_mutant[0])
            print(mutant_stru)



    ``def mutate_stru_with_rosetta``

    - ``Briefs``
        Mutate the {stru} to its {mutant} structure using Rosetta.

    - ``Input/Output``
        ``Input``:
            | ``stru``: The structure you need to mutant, generated by ``PDBParser``.
            | ``mutant``: A target list of mutation objects, generated by the ``assign_mutant`` function.
            
        ``Output``: 
            The reference/copy of the changed structure using Rosetta.

    - ``Arguments``
        ``stru``: 
            The target 'WT' structure.

        ``mutant``: 
            a list of Mutation() which describes a mutant to the 'WT'

        ``in_place``: 
            if make the changes to the structure in-place 

    - ``Example``
        .. code-block:: python
            
            from enzy_htp.structure import PDBParser
            import enzy_htp.mutation.api as mapi
            
            test_pdb = "./test_A.pdb"
            test_stru = PDBParser.get_structure(test_pdb)
            test_mutant = mapi.assign_mutant(test_stru, "GA11A")
            mutant_stru = mapi.mutate_stru_with_rosetta(test_stru, test_mutant[0])
            print(mutant_stru)



    ``def check_mutant_stru``

    - ``Briefs``
        Check the generated mutant stru with following options: topology: rings in structure should not be circling on bonds.

    - ``Input/Output``
        ``Input``:
            | ``mutant_stru``: The structure for checking, processed by ``PDBParser``.
            | ``mutant``: A list of target mutant, from clarification.

        ``Output``:
            Check result of the target sturcture.

    - ``Arguments``
        ``mutant_stru``:
            The target mutant structure for checking.

        ``mutants``: 
            A list of target mutant.
            
        ``checker_config``:
            The selected checker functions and keyword argument mapper of each checker function.
            Example:
            .. code-block:: python

                {
                'checker_name' : {
                'kwarg1' : value1,
                ...,
                },
                ...}


    - ``Example``
        .. code-block:: python

            import enzy_htp.mutation.api as mapi
            from enzy_htp.structure import PDBParser
            
            mutant_pdb = "./mut.pdb"
            mutant = [('GLU','ALA','A',11)]
            mutant_stru = PDBParser.get_structure(mutant_pdb)
            mapi.check_mutant_stru(mutant_stru, mutant)

    ``def check_mutation_topology_error``

    - ``Briefs``
        Check {stru} for topology error. (check for only the mutated residue) i.e.: rings in structure should not be circling on other bonds. An example of this error is in https://github.com/ChemBioHTP/EnzyHTP/issues/110

    - ``Input/Output``
        ``Input``:
            | ``mutant_stru``: The structure for checking, processed by ``PDBParser``.
            | ``mutant``: A list of target mutant, from clarification.

        ``Output``:
            Check result of the target sturcture.


    - ``Arguments``
        ``mutant_stru``:
            The target mutant structure for checking.

        ``mutants``: 
            A list of target mutant.

    - ``Example``
        .. code-block:: python

            import enzy_htp.mutation.api as mapi
            from enzy_htp.structure import PDBParser

            mutant_pdb = "./mut.pdb"
            mutant = [('GLU','ALA','A',11)]
            mutant_stru = PDBParser.get_structure(mutant_pdb)
            mapi.check_mutation_topology_error(mutant_stru, mutant)


4. Let's try to construct the actual scripts step by step.
=========================================================================================

.. panels::

    :column: col-lg-12 col-md-12 col-sm-12 col-xs-12 p-2 text-left

    We will utilize the structures test_A.pdb, test_A_B.pdb, and test_A_B_C_D.pdb to construct mutant structures with single chain or polymers. In these structures, A and B represent symmetrical subunits, while C and D denote symmetrical subunits distinct from A and B.

        1. Import the PDBParser class and make PDBParser instance. ``sp = PDBParser()`` and get the structure from the file provide with sp.get_structure(f"xxx.pdb"). Import mutation API as ``mapi``.
        2. Assign the mutant sites you want. 
        3. Select the symmetrical subunits (if required) you want to do, and define the chain mapper.
        4. Select the engine to build new structure.
        5. Check the structure after mutation.

    .. code:: python

        from enzy_htp.structure import PDBParser
        import enzy_htp.mutation.api as mapi

        #mutate a sigle chain protein
        test_A = "test_A.pdb"
        test_A_stru = PDBParser.get_structure(test_A)
        test_mutation_pattern_A = (
                "GA11A, {NA176W, PA51A},"
                " {L56A, r:2[resi 254 around 3:all not self]*5}"
                )
        mutants_A = mapi.assign_mutant(test_A_stru, test_mutation_pattern_A)
        mutant_stru_A_1 = mapi.mutate_stru(test_A_stru, mutants_A[0], "pymol") #mutate group1
        mutant_stru_A_2 = mapi.mutate_stru(test_A_stru, mutants_A[1], "pymol") #mutate group2
        mutant_stru_A_3 = mapi.mutate_stru(test_A_stru, mutants_A[2], "pymol") #mutate group3

        ##mutate a two-chain protein
        test_A_B = "test_A_B.pdb"
        test_A_B_stru = PDBParser.get_structure(test_A_B)
        test_mutation_pattern_A_B = (
                "{GA11A, NB176W, PB51A}"
                )
        mutation_pattern_A_B = mapi.assign_mutant(test_A_B_stru, test_mutation_pattern_A_B, chain_sync_list=[("A", "B")], chain_index_mapper={"A": 0,       "B": 0})
        mutant_stru_A_B = mapi.mutate_stru(test_A_B_stru, mutation_pattern_A_B[0], "tleap_min") 

        #mutate a four-chain protein
        test_A_B_C_D = "test_A_B_C_D.pdb"
        test_A_B_C_D_stru = PDBParser.get_structure(test_A_B_C_D)
        test_mutation_pattern_A_B_C_D = (
                "{TA391A, RC58A}"
                )
        mutation_pattern_A_B_C_D = mapi.assign_mutant(test_A_B_C_D_stru, test_mutation_pattern_A_B_C_D, chain_sync_list=[("A", "B"), ("C", "D")],       chain_index_mapper={"A": 0, "B": 0, "C": 0, "D": 0})
        mutant_stru_A_B_C_D = mapi.mutate_stru(test_A_B_C_D_stru, mutation_pattern_A_B_C_D[0], "tleap_min") 

        #check mutant structures
        mapi.check_mutant_stru(mutant_stru_A_2, mutants_A[1])
        mapi.check_mutant_stru(mutant_stru_A_B, mutation_pattern_A_B[0])
        mapi.check_mutant_stru(mutant_stru_A_B_C_D, mutation_pattern_A_B_C_D[0])
